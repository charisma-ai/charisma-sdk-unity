using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using BestHTTP;
using BestHTTP.Logger;
using BestHTTP.SocketIO;
using BestHTTP.SocketIO.JsonEncoders;
using BestHTTP.SocketIO.Transports;
using Newtonsoft.Json;
using PlatformSupport.Collections.ObjectModel;
using UnityEngine;

#pragma warning disable 618

namespace CharismaSDK
{
    public class Charisma : MonoBehaviour
    {
        #region Properties

        /// <summary>
        /// Returns true if the component is initialised
        /// </summary>
        public bool IsInitialised { get; set; }
        
        /// <summary>
        /// Returns true if the socket is open
        /// </summary>
        public bool IsConnected => _socket != null && _socket.IsOpen;
        
        /// <summary>
        /// Latest response received from Charisma
        /// </summary>
        public Response Response { get; internal set; }

        /// <summary>
        /// Our playthrough token
        /// </summary>
        public string Token { get; internal set; }

        /// <summary>
        /// Id of this conversation
        /// </summary>
        public Conversation Conversation { get; internal set; }

        /// <summary>
        /// The audio clip generated by the last response
        /// </summary>
        public AudioClip OutputAudio { get; internal set; }

        /// <summary>
        /// Settings for speech generation
        /// </summary>
        public SpeechStartOptions SpeechOptions { get; internal set; }
        
        #endregion

        #region Static
        
        #region Token Request

        /// <summary>
        /// Retrieve a playthrough token for the specific story id and version defined in the Charisma Settings
        /// - Subscribe to the OnTokenRecieved event to use
        /// </summary>
        /// <returns></returns>
        public void GetToken()
        {
            var settings = CharismaSettings.Instance;

            if (settings.StoryVersion != 0)
            {
                var socketRequestParams = new SocketMultiRequestParams(settings.StoryId, settings.StoryVersion);
                var requestString = JsonConvert.SerializeObject(socketRequestParams);    
                StartCoroutine(Post(requestString));
            }
            else
            {
                var socketRequestParams = new SocketSingleRequestParams(settings.StoryId);
                var requestString = JsonConvert.SerializeObject(socketRequestParams);
                StartCoroutine(Post(requestString));
            }
        }

        private IEnumerator Post(string requestString)
        {
            var request = new HTTPRequest(new Uri($"{CharismaSettings.Instance.BaseUrl}{CharismaSettings.TokenUrl}"), HTTPMethods.Post)
            {
                RawData = Encoding.UTF8.GetBytes(requestString)
            };

            // Only pass the user token if we are debugging
            if(CharismaSettings.Instance.IsDebugging)
                request.SetHeader("Authorization", $"Bearer {CharismaSettings.Instance.DebugToken}");
			
            request.AddHeader("Content-Type", "application/json");
            request.UseAlternateSSL = true;
            request.Send();
			
            if(_showLog)
                Debug.Log("HTTP: Requesting token");

            while (request.State != HTTPRequestStates.Finished)
                yield return null;

            if (request.Exception != null)
            {
                Debug.Log(request.Exception.ToString());
            }
            else
            {
                var response = Encoding.UTF8.GetString(request.Response.Data);

                Token = CharismaUtilities.TokenToString(response);
                                          
                OnTokenReceived?.Invoke(Token);             
                
                if(_showLog)
                    Debug.Log("HTTP: Token request complete");
            }
        }
              
        #endregion

        #region Conversation Request

        /// <summary>
        /// Create a new conversation
        /// </summary>
        /// <param name="token">Token associated with the playthrough we want to create a conversation for</param>
        /// <returns></returns>
        public void AddConversation(string token)
        {
            // TODO: Move to task based system
            StartCoroutine(GetConversation(token));          
            
            if(!IsInitialised)
                Initialise(token);
        }
        
        private IEnumerator GetConversation(string token)
        {            
            var request = new HTTPRequest(new Uri($"{CharismaSettings.Instance.BaseUrl}{CharismaSettings.ConversationUrl}"), HTTPMethods.Post)
            {
                RawData = Encoding.UTF8.GetBytes(token)
            };

            request.SetHeader("Authorization", $"Bearer {token}");
            request.UseAlternateSSL = true;
            request.Send();
            
            if(_showLog)
                Debug.Log("HTTP: Requesting conversation");
            
            while (request.State != HTTPRequestStates.Finished)
                yield return null;
            
            if (request.Exception != null)
                Debug.Log(request.Exception.ToString());
            else
            {
                var response = Encoding.UTF8.GetString(request.Response.Data);
                Conversation = CharismaUtilities.GenerateConversation(response);
                
                OnConversationInitialised?.Invoke(Conversation.conversationId);
                
                if(_showLog)
                    Debug.Log("HTTP: Conversation request complete");
            }         
        }

        #endregion

        #endregion
        
        #region Delegates

        public delegate void StoryEventDelegate(Response response, AudioClip clip, string url);
        public delegate void CharismaEventDelegate();
        public delegate void TokenEventDelegate(string token);
        public delegate void ConversationEventDelegate(int conversationId);
        
        
        private delegate void AudioGenerationDelegate();

        #endregion
        
        #region Events
        
        /// <summary>
        /// A new response has been received
        /// </summary>
        public event StoryEventDelegate OnReceivedResponse;
        
        /// <summary>
        /// Successfully connected to the server
        /// </summary>
        public event CharismaEventDelegate OnConnected;
        
        /// <summary>
        /// Successfully set memory
        /// </summary>
        public event CharismaEventDelegate OnMemorySet;
        
        /// <summary>
        /// Successfully generated a token
        /// </summary>
        public event TokenEventDelegate OnTokenReceived;
        
        /// <summary>
        /// Successfully initialised a conversation
        /// </summary>
        public event ConversationEventDelegate OnConversationInitialised;        
        
        #endregion

        #region Member variables

        [SerializeField] private bool _showLog;
        
        private SocketManager _socketManager;
        private Socket _socket;
        private bool _isProcessing;

        #endregion

        #region Threading

        private static readonly Queue<Action> ExecuteOnMainThread = new Queue<Action>();

        #endregion

        #region Monobehaviour Callbacks

        private void Start()
        {
            // Enable threading
            HTTPUpdateDelegator.IsThreaded = true;
        }

        private void Update()
        {
            // Dispatch on main thread.
            while (ExecuteOnMainThread.Count > 0)
            {
                ExecuteOnMainThread.Dequeue().Invoke();
            }
        }

        #endregion

        #region Initialisers

        /// <summary>
        /// Initialise with HTTP log level
        /// </summary>
        /// <param name="token"></param>
        /// <param name="logLevel"></param>
        public void Initialise(string token, Loglevels logLevel)
        {   
            Token = token;
            HTTPManager.Logger.Level = logLevel;
                        
            SpeechOptions = new SpeechStartOptions(CharismaSettings.Instance.AudioConfig.Output,
                CharismaSettings.Instance.AudioConfig.AudioEncoding);
            
            IsInitialised = true;
        }
        
        /// <summary>
        /// Initialise with default HTTP log level
        /// </summary>
        /// <param name="token"></param>
        public void Initialise(string token)
        {             
            Token = token;
            HTTPManager.Logger.Level = Loglevels.Error;
            
            SpeechOptions = new SpeechStartOptions(CharismaSettings.Instance.AudioConfig.Output,
                CharismaSettings.Instance.AudioConfig.AudioEncoding);

            IsInitialised = true;
        }

        #endregion

        #region Connect

        /// <summary>
        /// Connect to Charisma
        /// </summary>
        public void Connect()
        {
            if(IsConnected) return;
            
            if(string.IsNullOrWhiteSpace(Token))
                {
                    Debug.LogError(
                        "No token provided. Make sure to request a new token or provide a previously generated one before connecting.");
                    return;
                }

            var options = new SocketOptions
            {
                ConnectWith = TransportTypes.WebSocket,
                AdditionalQueryParams = new ObservableDictionary<string, string> {{"token", Token}}
            };

            var manager = new SocketManager(new Uri($"{CharismaSettings.Instance.BaseUrl}{CharismaSettings.ServerUrl}"), options)
            {
                Encoder = new LitJsonEncoder()
            };
            
            _socket = manager.GetSocket("/play");
            
            _socket.On(SocketIOEventTypes.Connect, (socket, packet, args) =>
            {
                if(_showLog)
                    Debug.Log("Socket: Connected");
                
                _socketManager = manager;
            });
			
            _socket.On("error", (socket, packet, args) => {		
				
                Debug.LogError(args[0].ToString());								
            });		
			
            _socket.On("status", (socket, packet, args) => {
				
                if(_showLog)
                    Debug.Log("Socket: Status ready");		
				
                OnConnected?.Invoke();		
            });
			
            _socket.On("message", (socket, packet, args) =>
            {
                Response = CharismaUtilities.GenerateResponse(packet.Payload);	                
      
                if(Response.Message.Speech != null)
                    if (SpeechOptions.output == "url")
                    {
                        OnReceivedResponse?.Invoke(Response, null, Response.Message.Speech.Audio.Url);  
                    }
                    else
                    {
                        ExecuteOnMainThread.Enqueue(() =>
                        {
                            StartCoroutine(GenerateAudio(Response));                           
                        });             
                    }
                else
                {
                    ExecuteOnMainThread.Enqueue(() =>
                    {
                        SendReceivedResponse();                     
                    });                   
                }
                
                // We are done processing this response
                _isProcessing = false;           
                
                if(_showLog)
                    Debug.Log($"Charisma: Received response: {Response.Message.Text}");                           
            });
			
            _socket.On("start-typing", (socket, packet, args) =>
            {
                _isProcessing = true;
                
                if(_showLog)
                    Debug.Log("Charisma: Processing response");
            });
			
            _socket.On("stop-typing", (socket, packet, args) =>
            {
                if(_showLog)
                    Debug.Log("Charisma: Finished processing response");
            });
			
            _socket.On("problem", (socket, packet, args) =>
            {
                if(_showLog)
                    Debug.Log(packet.Payload);
            });

            _socket.On("set-memory", (socket, packet, args) =>
            {
                if(_showLog)
                    Debug.Log($"Charisma: successfully {packet.Payload}");
            });
        }
        
        #endregion
        
        #region Interaction

        private void SendReceivedResponse()
        {
            OnReceivedResponse?.Invoke(Response, OutputAudio, null);
        }

        /// <summary>
        /// Start the story from selected scene
        /// </summary>
        /// <param name="sceneIndex">The scene to start from</param>
        /// <param name="speech">Should speech be used for this interaction</param>
        public void StartInteraction(int sceneIndex, bool speech)
        {
            if (_socket == null)
            {
                Debug.LogError("Charisma: Socket not open. Connect before starting the interaction");
                return;
            };

            if (speech)
            {
                var startOptions = new CharismaStartOptions(Conversation.conversationId, sceneIndex, SpeechOptions);			
                _socket?.Emit("start", startOptions);			
            }
            else
            {
                var startOptions = new CharismaStartOptions(Conversation.conversationId, sceneIndex);			
                _socket?.Emit("start", startOptions);		
            }
            
            if(_showLog)
                Debug.Log("Charisma: Starting interaction");
        }

        /// <summary>
        /// Start the story from selected scene
        /// </summary>
        /// <param name="sceneIndex">The scene to start from</param>
        /// <param name="speech">Should speech be used for this interaction</param>
        /// <param name="conversation"></param>
        public void StartInteraction(int sceneIndex, bool speech, Conversation conversation)
        {
            if (_socket == null)
            {
                Debug.LogError("Charisma: Socket not open. Connect before starting the interaction");
                return;
            };

            if (speech)
            {
                var startOptions = new CharismaStartOptions(conversation.conversationId, sceneIndex, SpeechOptions);			
                _socket?.Emit("start", startOptions);			
            }
            else
            {
                var startOptions = new CharismaStartOptions(conversation.conversationId, sceneIndex);			
                _socket?.Emit("start", startOptions);		
            }
            
            if(_showLog)
                Debug.Log("Charisma: Starting interaction");
        }


        /// <summary>
        /// Send a tap event to Charisma.
        /// </summary>
        public void Tap()
        {
            if (_socket == null)
            {
                Debug.LogError("Charisma: Socket not open. Connect before sending commands");
                return;
            };
            
            var tapOptions = new TapOptions(Conversation, SpeechOptions);
            _socket?.Emit("tap", tapOptions);
            
            if(_showLog)
                Debug.Log("Charisma: Tap");
        }
        
        /// <summary>
        /// Send a tap event to Charisma.
        /// </summary>
        /// <param name="speech">Set true if the next response should contain speech</param>
        public void Tap(bool speech)
        {
            if (_socket == null)
            {
                Debug.LogError("Charisma: Socket not open. Connect before sending commands");
                return;
            };
                       
            var tapOptions = speech ? new TapOptions(Conversation, SpeechOptions) : new TapOptions(Conversation);
            _socket?.Emit("tap", tapOptions);
            
            if(_showLog)
                Debug.Log("Charisma: Tap");
        }

        /// <summary>
        /// Send a tap event to Charisma.
        /// </summary>
        /// <param name="speech">Set true if the next response should contain speech.</param>
        /// <param name="conversation">Conversation to sent tap to.</param>
        public void Tap(bool speech, Conversation conversation)
        {
            if (_socket == null)
            {
                Debug.LogError("Charisma: Socket not open. Connect before sending commands");
                return;
            };
                       
            var tapOptions = speech ? new TapOptions(conversation, SpeechOptions) : new TapOptions(conversation);
            _socket?.Emit("tap", tapOptions);
            
            if(_showLog)
                Debug.Log("Charisma: Tap");
        }

        /// <summary>
        /// Set a memory in Charisma.
        /// </summary>
        /// <param name="memory">The memory to be set. Needs to have the same Key as the corresponding memory in Charisma.</param>
        public void SetMemory(Memory memory)
        {
            StartCoroutine(AttemptSetMemory(memory));
        }
        
        private IEnumerator AttemptSetMemory(Memory memory)
        {
            if (_socket == null)
            {
                Debug.LogError("Charisma: Socket not open. Connect before trying to set memory");
                yield return null;
            };
            
            var request = new HTTPRequest(new Uri($"{CharismaSettings.Instance.BaseUrl}{CharismaSettings.SetMemoryUrl}"), HTTPMethods.Post)
            {
                RawData = Encoding.UTF8.GetBytes(CharismaUtilities.MemoryToJson(memory))
            };
           
            request.SetHeader("Authorization", $"Bearer {Token}");			
            request.AddHeader("Content-Type", "application/json");
            request.UseAlternateSSL = true;
            request.Send();
			
            while (request.State != HTTPRequestStates.Finished)
                yield return null;

            if (request.Exception == null)
            {
                Debug.Log($"Charisma: Set memory: '{memory.MemoryRecallValue}' with value '{memory.SaveValue}'"); 
                OnMemorySet?.Invoke();
            }
            else
                Debug.Log(request.Exception);                      
        }
                
        /// <summary>
        /// Set mood in Charisma. 
        /// </summary>
        public void SetMood()
        {
            // TODO: Move to post request  
        }

        /// <summary>
        /// Send player message with speech to Charisma
        /// </summary>
        /// <param name="message">Message to send</param>
        public void SendPlayerMessage(string message)
        {
            if (_socket == null)
            {
                Debug.LogError("Charisma: Socket not open. Connect before sending player message");
                return;
            };

            if (_isProcessing)
            {
                Debug.LogWarning("Charisma: Cannot send player message when Charisma is processing");
                return;
            }
            			
            var playerMessage = new PlayerMessage(message, SpeechOptions, Conversation.conversationId);
            _socket?.Emit("reply", playerMessage);		
			
            if(_showLog)
                Debug.Log("Charisma: Sending player message");
        }

        /// <summary>
        /// Send player message to Charisma
        /// </summary>
        /// <param name="message">Message to send</param>
        /// <param name="speech">Set true if the next response should contain speech</param>
        public void SendPlayerMessage(string message, bool speech)
        {
            if (_socket == null)
            {
                Debug.LogError("Charisma: Socket not open. Connect before sending player message");
                return;
            };

            if (_isProcessing)
            {
                Debug.LogWarning("Charisma: Cannot send player message when Charisma is processing");
                return;
            }
            
            var playerMessage = speech
                ? new PlayerMessage(message, SpeechOptions, Conversation.conversationId)
                : new PlayerMessage(message, Conversation.conversationId);
            _socket?.Emit("reply", playerMessage);
                
            if(_showLog)
                Debug.Log("Charisma: Sending player message");
        }

        /// <summary>
        /// Send player message to Charisma
        /// </summary>
        /// <param name="message">Message to send</param>
        /// <param name="speech">Set true if the next response should contain speech</param>
        /// <param name="conversation">Conversation to interact with</param>
        public void SendPlayerMessage(string message, bool speech, Conversation conversation)
        {
            if (_socket == null)
            {
                Debug.LogError("Charisma: Socket not open. Connect before sending player message");
                return;
            };

            if (_isProcessing)
            {
                Debug.LogWarning("Charisma: Cannot send player message when Charisma is processing");
                return;
            }

            var playerMessage = speech
                ? new PlayerMessage(message, SpeechOptions, conversation.conversationId)
                : new PlayerMessage(message, conversation.conversationId);
            _socket?.Emit("reply", playerMessage);
                
            if(_showLog)
                Debug.Log("Charisma: Sending player message");  
        }
        
        #endregion

        #region Audio

        private IEnumerator GenerateAudio(Response response)
        {
            if (SpeechOptions.encoding == "mp3")
            {
                if(_showLog)
                    Debug.Log("Charisma: Generating audio");
            
                var tempFile = Application.persistentDataPath + "/bytes.mp3";
                
                if(response.Message.Speech.Audio.Data != null)
                    System.IO.File.WriteAllBytes(tempFile, response.Message.Speech.Audio.Data);
                       
                var clip = new WWW ("file://" + tempFile);
			
                // Wait until the clip is loaded.
                while(!clip.isDone){ 
                    yield return null;
                }

                // Generate the clip
                OutputAudio = CharismaUtilities.FromMp3Data(clip.bytes);		
                SendReceivedResponse();
            }
            else
            {
                if(_showLog)
                    Debug.Log("Charisma: Generating audio");
            
                var tempFile = Application.persistentDataPath + "/bytes.ogg";

                if(response.Message.Speech.Audio.Data != null)
                    System.IO.File.WriteAllBytes(tempFile, response.Message.Speech.Audio.Data);
                       
                var clip = new WWW ("file://" + tempFile);
			
                // Wait until the clip is loaded.
                while(!clip.isDone){ 
                    yield return null;
                }

                // Generate the clip
                OutputAudio = clip.GetAudioClip(false, false, AudioType.OGGVORBIS);
                SendReceivedResponse();           
            }
        }
        
        #endregion

        #region Termination

        private void OnApplicationQuit()
        {           
            Disconnect();
        }

        // Disconnect from the current interaction.
        public void Disconnect()
        {
            if (_socket == null) return;
            if (_socketManager == null) return;            
            
            try
            {
                _socket.Disconnect();
                _socket = null;
                _socketManager.Close();
                _socketManager = null;
            }
            catch (Exception e)
            {
                Debug.LogError($"Charisma: failed to disconnect: {e}");
                return;
            }
            
            if(_showLog)
                Debug.Log("Charisma: Successfully disconnected");
        }

        #endregion
    }
}


