using System;
using Newtonsoft.Json;
using UnityEngine;
using Colyseus;
using CharismaSDK.Sound;
using System.Collections.Generic;
using System.Threading.Tasks;
using System.Collections;

namespace CharismaSDK
{
    /// <summary>
    /// Interact with Charisma using this object.
    /// </summary>
    public class Playthrough
    {
        #region Enums
        public enum ConnectionState
        {
            Disconnected,
            Connecting,
            Connected,
            Reconnecting
        }
        #endregion

        #region Static Variables

        private const string BaseUrl = "wss://play.charisma.ai";

        // Ping constants
        private const float TIME_BETWEEN_PINGS = 2.0f;
        private const int MINIMUM_PINGS_TO_CONSIDER_FAILED = 3;

        // Reconnection constants
        private const int MAXIMUM_RECONNECTION_ATTEMPTS = 60;

        #endregion

        #region Properties

        /// <summary>
        /// The last token that was generated.
        /// </summary>
        public string Token { get; }

        /// <summary>
        /// The UUID of the playthrough.
        /// </summary>
        public string PlaythroughUuid { get; }

        /// <summary>
        /// Assign a new Speech config.
        ///  - To add speech, pass in a new speech config.
        ///  - To remove audio, set this to null.
        /// </summary>
        public SpeechOptions SpeechOptions => _speechOptions;

        /// <summary>
        /// Assign a Speech recognition config.
        ///  - used only when speechRecognition is enabled
        /// </summary>
        public SpeechRecognitionOptions SpeechRecognitionOptions => _speechRecognitionOptions;

        #endregion

        #region Degelates

        public delegate void MessageDelegate(Events.MessageEvent message);
        public delegate void StartTypingDelegate(Events.StartTypingEvent message);
        public delegate void StopTypingDelegate(Events.StopTypingEvent message);
        public delegate void ConnectionStateChangeDelegate(ConnectionState connectionState);
        public delegate void SpeechRecognitionResultDelegate(Events.SpeechRecognitionResult result);
        public delegate void PingSuccessDelegate();
        public delegate void PingFailureDelegate();

        #endregion

        #region Events

        /// <summary>
        /// Called when a new message has been generated by Charisma.
        /// </summary>
        public event MessageDelegate OnMessage;

        /// <summary>
        /// Called when a character has started typing.
        /// </summary>
        public event StartTypingDelegate OnStartTyping;

        /// <summary>
        /// Called when a character has stopped typing.
        /// </summary>
        public event StopTypingDelegate OnStopTyping;

        /// <summary>
        /// Called when the connection state of the playthrough to Charisma changes.
        /// </summary>
        public event ConnectionStateChangeDelegate OnConnectionStateChange;

        /// <summary>
        /// Called when valid speech is detected from the local audio Input.
        /// </summary>
        public event SpeechRecognitionResultDelegate OnSpeechRecognitionResult;

        /// <summary>
        /// Called when a pong event is received successfully from the Playthrough host.
        /// </summary>
        public event PingSuccessDelegate OnPingSuccess;

        /// <summary>
        /// Called when a ping event has failed to trigger a pong from the Playthrough host.
        /// </summary>
        public event PingFailureDelegate OnPingFailure;

        #endregion

        #region MemberVariables

        private ColyseusClient _client;
        private Dictionary<string, object> _roomOptions;
        private ColyseusRoom<object> _room;


        // use default empty constructor for initialisation
        // these setting should be in the playthrough anyway
        private SpeechOptions _speechOptions = new SpeechOptions();
        private SpeechRecognitionOptions _speechRecognitionOptions = new SpeechRecognitionOptions();

        private Sound.Microphone _microphone;

        private ConnectionState _connectionState;

        private Action _onReadyCallback;

        private int _pingCount = 0;
        private int _reconnectionTryCount = 0;

        private float _reconnectionTryDelay = 5.0f;

        private bool _calledByDisconnect;
        #endregion

        #region Constructors

        /// <summary>
        /// Interaction with Charisma
        /// </summary>
        /// <param name="token">A valid play-though token.</param>
        public Playthrough(string token, string playthroughUuid, SpeechOptions speechOptions = default, SpeechRecognitionOptions speechRecognitionOptions = default)
        {
            Token = token;
            PlaythroughUuid = playthroughUuid;

            // keep initial empty constructor instances
            // unless we receive new values
            if (speechOptions != default)
            {
                _speechOptions = speechOptions;
            }

            if (speechRecognitionOptions != default)
            {
                _speechRecognitionOptions = speechRecognitionOptions;
            }

            SetConnectionState(ConnectionState.Disconnected);
        }

        ~Playthrough()
        {
            Disconnect();
        }

        #endregion

        #region Connect / Disconnect

        /// <summary>
        /// Connect to Charisma
        /// </summary>
        /// <param name="onReadyCallback">Called when successfullyconnected to Charisma.</param>
        public void Connect(Action onReadyCallback)
        {
            if (IsConnected())
            {
                Logger.Log("Playthrough is already connected. Exiting early.");
                return;
            }

            SetConnectionState(ConnectionState.Connecting);

            _onReadyCallback = onReadyCallback;

            CreateClientAndJoinRoom();
        }

        // Disconnect from the current interaction.
        public void Disconnect()
        {
            if (!HasBeenDisconnected())
            {
                Logger.Log("Playthrough is already disconnected. Exiting early.");
                return;
            }

            try
            {
                _room?.Leave();
                _room = null;

                _client = null;

                // Disconnected manually set to true.
                _calledByDisconnect = true;

                SetConnectionState(ConnectionState.Disconnected);
            }
            catch (Exception e)
            {
                Logger.LogError($"Failed to disconnect: {e}");
                return;
            }

            Logger.Log("Successfully disconnected");
        }

        #endregion

        #region Interaction

        public void SetSpeechConfig(SpeechOptions speechOptions)
        {
            _speechOptions = speechOptions;
        }

        /// <summary>
        /// Starts the story. Can be from a particular scene or subplot, or the beginning of the story, depending on the value of the `startOptions` parameter.
        /// </summary>
        /// <param name="startOptions">Options to send with the `start` event.</param>
        public void Start(
            string conversationUuid,
            int? sceneIndex = null,
            string startGraphReferenceId = null
        )
        {
            if (!IsConnected())
            {
                Logger.LogError("Socket not open. Connect before starting the interaction");
                return;
            };

            var startEvent = new Events.StartEvent(conversationUuid, sceneIndex, startGraphReferenceId, SpeechOptions);

            Logger.Log($"Sending `start` event: {JsonConvert.SerializeObject(startEvent)}");
            _room?.Send("start", startEvent);
        }

        /// <summary>
        /// Start the story from selected scene.
        /// </summary>
        /// <param name="conversationUuid">Id of the conversation we want to resume.</param>
        public void Resume(string conversationUuid)
        {
            if (!IsConnected())
            {
                Logger.LogError("Socket not open. Connect before resuming the interaction");
                return;
            };

            var resumeEvent = new Events.ResumeEvent(conversationUuid, SpeechOptions);

            Logger.Log($"Sending `resume` event: {JsonConvert.SerializeObject(resumeEvent)}");
            _room?.Send("resume", resumeEvent);
        }

        /// <summary>
        /// Send a tap event to Charisma.
        /// </summary>
        /// <param name="conversationUuid">Id of the conversation the tap should be sent to.</param>
        public void Tap(string conversationUuid)
        {
            if (!IsConnected())
            {
                Logger.LogError("Socket not open. Connect before starting the interaction");
                return;
            };

            var tapEvent = new Events.TapEvent(conversationUuid, SpeechOptions);

            Logger.Log($"Sending `tap` event: {JsonConvert.SerializeObject(tapEvent)}");
            _room?.Send("tap", tapEvent);
        }


        /// <summary>
        /// Send player response to Charisma.
        /// </summary>
        /// <param name="text">Message to send.</param>
        /// <param name="conversationUuid">Conversation to interact with.</param>
        public void Reply(string conversationUuid, string text)
        {
            if (!IsConnected())
            {
                Logger.LogError("Socket not open. Connect before starting the interaction");
                return;
            };

            var replyEvent = new Events.ReplyEvent(conversationUuid, text, SpeechOptions);

            Logger.Log($"Sending `reply` event: {JsonConvert.SerializeObject(replyEvent)}");
            _room?.Send("reply", replyEvent);
        }

        /// <summary>
        /// Send player action to Charisma.
        /// </summary>
        /// <param name="action">The action to send.</param>
        /// <param name="conversationUuid">Conversation to interact with.</param>
        public void Action(string conversationUuid, string action)
        {
            if (!IsConnected())
            {
                Logger.LogError("Socket not open. Connect before starting the interaction");
                return;
            };

            var actionEvent = new Events.ActionEvent(conversationUuid, action, SpeechOptions);

            Logger.Log($"Sending `action` event: {JsonConvert.SerializeObject(actionEvent)}");
            _room?.Send("action", actionEvent);
        }

        public void Pause()
        {
            if (!IsConnected())
            {
                Logger.LogError("Socket not open. Connect before starting the interaction");
                return;
            };

            Logger.Log("Sending `pause` event");
            _room?.Send("pause");
        }

        public void Play()
        {
            if (!IsConnected())
            {
                Logger.LogError("Socket not open. Connect before starting the interaction");
                return;
            };

            Logger.Log("Sending `play` event");
            _room?.Send("play");
        }

        public void StartSpeechRecognition(GameObject gameObject, int microphoneId = 0)
        {
            if (!IsConnected())
            {
                Logger.LogError("Socket not open. Connect before starting the interaction");
                return;
            };

            if (_microphone == null)
            {
                _microphone = gameObject.TryGetComponent(out Sound.Microphone mic) ? mic : gameObject.AddComponent<Sound.Microphone>();
            }

            _microphone.Initialize(microphoneId, _speechRecognitionOptions.SampleRate);
            _microphone.MicrophoneCallback += data => _room?.Send("speech-recognition-chunk", data);

            var speechRecognitionOptions = new Dictionary<string, object>
            {
                ["service"] = _speechRecognitionOptions.Service,
                ["sampleRate"] = _speechRecognitionOptions.SampleRate
            };

            if (_speechRecognitionOptions.LanguageCode != default)
            {
                speechRecognitionOptions.Add("languageCode", _speechRecognitionOptions.LanguageCode);
            }

            _room?.Send("speech-recognition-start", speechRecognitionOptions);
            _microphone.StartListening();
        }

        public void StopSpeechRecognition()
        {
            _room?.Send("speech-recognition-stop");
            _microphone.MicrophoneCallback = null;
            _microphone.StopListening();
        }

        #endregion

        #region Private functions
        private void SetConnectionState(ConnectionState connectionState)
        {
            if (_connectionState != connectionState)
            {
                Logger.Log($"Setting connection state to {connectionState}.");
                _connectionState = connectionState;
                OnConnectionStateChange?.Invoke(connectionState);
            }
        }

        private bool IsConnected()
        {
            return _connectionState == ConnectionState.Connected;
        }

        private bool HasBeenDisconnected()
        {
            return _connectionState == ConnectionState.Disconnected;
        }

        private async void CreateClientAndJoinRoom()
        {
            _client = new ColyseusClient(BaseUrl);

            _roomOptions = new Dictionary<string, object>
            {
                ["token"] = Token,
                ["playthroughId"] = PlaythroughUuid,
                ["sdkInfo"] = new Dictionary<string, object>
                {
                    ["sdkId"] = "unity",
                    ["sdkVersion"] = "0.2.0",
                    ["protocolVersion"] = 1
                }
            };

            ColyseusRoom<dynamic> room = await _client.JoinOrCreate(
                "chat",
                _roomOptions
            );

            _room = room;
            AssignRoomCallbacks();
        }

        private void AssignRoomCallbacks()
        {
            _room.OnJoin += () =>
            {
                Logger.Log("Successfully connected to playthrough");
            };


            _room.OnError += (code, message) =>
            {
                Logger.LogError($"There was an error connecting to the playthrough. Code: {code}. Message: {message}");
            };

            _room.OnMessage<string>("status", (status) =>
            {
                Logger.Log($"Received `status` event: {JsonConvert.SerializeObject(status)}");
                if (status == "ready")
                {
                    Logger.Log("Ready to begin play");
                    OnReady();
                }
            });

            _room.OnMessage<Events.MessageEvent>("message", (message) =>
            {
                Logger.Log($"Received `message` event: {JsonConvert.SerializeObject(message)}");
                OnMessage?.Invoke(message);
            });

            _room.OnMessage<Events.StartTypingEvent>("start-typing", (message) =>
            {
                Logger.Log($"Received `start-typing` event: {JsonConvert.SerializeObject(message)}");
                OnStartTyping?.Invoke(message);
            });

            _room.OnMessage<Events.StopTypingEvent>("stop-typing", (message) =>
            {
                Logger.Log($"Received `stop-typing` event: {JsonConvert.SerializeObject(message)}");
                OnStopTyping?.Invoke(message);
            });

            _room.OnMessage<Events.SpeechRecognitionResult>("speech-recognition-result", (message) =>
            {
                Logger.Log($"Received `speech-recognition-result` event: {JsonConvert.SerializeObject(message)}");
                OnSpeechRecognitionResult?.Invoke(message);
            });

            _room.OnMessage<Events.ProblemEvent>("problem", (message) =>
            {
                Logger.LogWarning($"Received `problem` event: {JsonConvert.SerializeObject(message)}");
            });

            _room.OnMessage<string>("pong", (message) =>
            {
                _pingCount = 0;
                OnPingSuccess?.Invoke();
                SetConnectionState(ConnectionState.Connected);
            });

            _room.OnLeave += (code) =>
            {
                Logger.Log($"Connection closed. Attempting to reconnect to Playthrough.");
                MainThreadDispatcher.Instance.Consume(TryToReconnect());
            };
        }

        private void OnReady()
        {
            SetConnectionState(ConnectionState.Connected);

            _onReadyCallback?.Invoke();

            _calledByDisconnect = false;
            _reconnectionTryCount = 0;

            Task.Run(FirePing);
        }

        private IEnumerator TryToReconnect()
        {
            if (_calledByDisconnect)
            {
                SetConnectionState(ConnectionState.Disconnected);
                yield break;
            }

            // cannot allow multiple reconnection coroutines to run concurrently
            if (IsReconnecting())
            {
                yield break;
            }

            Logger.Log("Trying to reconnect.");
            SetConnectionState(ConnectionState.Reconnecting);

            MainThreadDispatcher.Instance.Consume(Reconnect());
        }

        private bool IsReconnecting()
        {
            return _connectionState == ConnectionState.Reconnecting;
        }

        private IEnumerator Reconnect()
        {
            bool roomExpired = false;
            ColyseusRoom<object> room = null;

            while (room == null)
            {
                _reconnectionTryCount++;

                if (_reconnectionTryCount <= MAXIMUM_RECONNECTION_ATTEMPTS)
                {
                    // Need to set the protocol to secure every time.
                    // Colyseus resets to non-secure after even one failed attempt
                    _client.Settings.useSecureProtocol = true;

                    Task<ColyseusRoom<object>> reconnectionTask;
                    if (roomExpired)
                    {
                        // If the room has expired, attempt to create a new one.
                        reconnectionTask = _client.JoinOrCreate("chat", _roomOptions);
                    }
                    else
                    {
                        // Try just reconnecting otherwise.
                        reconnectionTask = _client.Reconnect(_room.Id, _room.SessionId);
                    }

                    yield return new WaitUntil(() => reconnectionTask.IsCompleted);

                    if (reconnectionTask.Status != TaskStatus.Faulted)
                    {
                        room = reconnectionTask.Result;

                        // If the room is successfully generated and no error is catched
                        // code will progress here and re-assign the _room variable.
                        _room = room;
                        AssignRoomCallbacks();
                        SetConnectionState(ConnectionState.Connected);
                        Logger.Log($"Successfully reconnected.");
                        yield break;
                    }
                    else
                    {
                        var exception = reconnectionTask.Exception;

                        Logger.LogWarning($"Failed to reconnect - exception: {exception.Message}");

                        // listen for "Room */ not found" error messages
                        // must re-create room as a result, as room has expired
                        if (!roomExpired)
                        {
                            var indexOfRoom = exception.Message.IndexOf("room");
                            var indexOfNotFound = exception.Message.IndexOf("not found");
                            if (indexOfRoom != -1 && indexOfRoom < indexOfNotFound)
                            {
                                roomExpired = true;
                            }
                        }
                    }

                    float timePassed = 0f;
                    while (timePassed < _reconnectionTryDelay)
                    {
                        yield return new WaitForEndOfFrame();
                        timePassed += Time.deltaTime;
                    }
                }
                else
                {
                    Logger.Log("Reached reconnection attempt limit - disconnecting...");
                    SetConnectionState(ConnectionState.Disconnected);
                    break;
                }
            }

        }

        private void FirePing()
        {
            if (!IsConnected())
            {
                return;
            }

            _room?.Send("ping");

            _pingCount++;
            if (_pingCount >= MINIMUM_PINGS_TO_CONSIDER_FAILED)
            {
                Logger.LogError($"Ping timed out.");
                SetConnectionState(ConnectionState.Disconnected);

                OnPingFailure?.Invoke();
                MainThreadDispatcher.Instance.Consume(TryToReconnect());
                return;
            }

            // Fire another ping after a delay.
            Task.Run(async delegate
            {
                await Task.Delay(TimeSpan.FromSeconds(TIME_BETWEEN_PINGS));
                FirePing();
            });
        }
        #endregion
    }
}
